!!!!!!!!!! use this for something useful
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

- why are the unit conversions so slow?
  - is there a different way to think about triples that would make them 
    faster?  objects vertex/edge perhaps?
  - where are we needlessly searching?
  - how can we avoid it?
    - predict best direction to search in?
    - general faster searching/matching?

simplify
  - refactor SimpleSparql out -> Axpress or just ax ?
  - use ENV paths
  - use relative paths. can see every translation in local direcotry like
    python (*.ax)
  - temp data path standard - .axpress
  - allow code with #!/usr/bin/axpress
  - clean up Evaluator.evalute
  - clean up all of Compiler ... again

  - heavy refactor : what are component steps, how to name things differently to that effect.  also less confused overloading of how to find bindings, matches, etc.  matching one intermediate form with another hsa slight differences ...

bugs/features:
  - read_translate bindings_set recompiles for each bindings - should only need to compile once
  - disallow input variable names like bnode1 to avoid confusion and errors

conceptual:
  - lots of confusion is inevitable to due overloading list as a list of possibilities as well as an actual list
    perhaps something like this:
        class Set(list) : pass
        class SetMaker() :
            def __getitem__(self, *args) :
                return Set(*args)
        S = SetMaker()
        print S[1,2,3]
  - make optional parts of a query and part of a translation work
  - lisp/clojure sure is tempting ... if only I weren't 5 years in ...
    - not sure it really would be best, but there are some nice parts for sure

---

See also dwi Axpress.Todo
