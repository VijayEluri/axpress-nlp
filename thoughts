* what is the MVP?
  * a few representative 'apps'/domains
    * see set of apps below
  * a clean web page
  * simple andoid app (polished ?)
  * solid logging ?  I think to keep track of what people are asking so effort can be placed efficiently
* version 2
  * demo? (video)
  * freebase?
  * anything that could be cafe/bar tested?
     * if you could ask a computer anything, what would you ask it?

* high level features
  * context
    * weather in btown; what about indi?
      * this seems like it will require storing various parts of the original 
        query like btown.  Consider these cases:
          weather in btown; what about (in |)indi
          weather in btown; what about the traffic there?
        in one case the subject is changing, in the other the property is chaning
  * translation coding
    * let me first write a few apps the slow way and see how they go
    * how to do function calls better ... like string concatenation
    * web interface for editing sets of translations ?
      * I've never liked coding in a browser ...
    * be able to search for a set of translations.  For example:
        view all simple_display translations
      You might want to see them all together.  You might also want some of the 
      spefic ones to appear with the specific other translations they interact
      with.
    * it is important that writing translations be easy.
    * coders shouldn't need to enumerate all of the "show me all of my %x%"
      all of the time.  I don't think this should be too hard ... just need
      to wait and see what the first few cases of this look like and figure 
      from there what the abstraction should look like.
  * debugging
    * syhead is kinda working for this ...
    * the paths get quite large ...
    * better common error checking:
      * multiple bindings to different places
      * misspellings (rare names that are very similar to common names)
  * optimizations:
    * traverse through translation_matrix a few steps ahead.  some paths may never
      lead to a solution.
      * create deep translation_matrix.  quickly determine if a translation 
        will ever lead to a triple with all of the out vars in it
    * find translations which have an input property that is only generated by one
      or two other translations.  This could help reduce the overhead to execute 
      "calls" where one translation is basically 'calling' another.
    * keep track of which translations are used to get to which solutions.  If a
      translation has never been used to reach this solution, search it last
  * different display depending on the input
    * "day of prayer" => sunday
    * "sunday" => 2011-12-16
    * this breaks many things ... hold off for now
    * this leads to wolfram alpha type displays where different views of the 
      same 'thing'.  This solution doesn't work for with voice output since
      it would overwhelm the user.  Also though, the voice output could ask for
      more details about what information about the thing the user wants ...
      thats not too bad
  * users training axpress
    * if a user tries a command and axpress doesn't know what it means, the
      user could try reprashing the command.  With lots of this kind of data, 
      we might be able to automatically derive new rephrasings of rules ...
    * what would be really cool would be if we could create whole new rules, not
      just new rephrasings, but then you start getting into programming ...
      the real task is to figure out how to most easily allow anyone to create
      new rules and teach axpress.  Some things are hard, like creating a
      new computer vision library, others are easier ...
  * android app?
  * web app?

* apps
  * todo list
    * very simple version done
    * slightly better css
    * ajax
    * use remember the milk as backend
  * better weather app (ok for now ...)
    * forecast
    * nicer looking
    * show what was asked for, but also other relevant information
      * ! dew point translation directly to a display format is a bit odd ...
        * it seems that it might be due to the fact that the dew point will
          be present from the weather lookup even if the weather lookup was only
          to lookup the current weather.  At that point in the search space
          all kinds of information is known, so some hints as to which 
          information was asked for need to be leeked out to the display path
      * ! also, with the weather example, there are a bunch of paths that are 
          very similar.  Like dew point, or barometeric pressure, etc.  How can
          those code paths be DRY?
  * !!! yelp
    * pizza
    * beer and buffalo wings
    * nearby stores
  * !!! check email, calendar - just for matching siri, good example
    * get/set address, phone number, birthday
    * when is my meeting with Joe?
  * !!! search on wikipedia
  * set an alarm - some UI stuff to figure out how this works
    * android: http://developer.android.com/reference/android/provider/AlarmClock.html
    * on desktop, this app doesn't make a whole lot of sense
    * should be relatively easy, but makes more sense on phone ...
    * nicer looking - show countdown timer for short alarms
    * fine for now to leave most of the work on the server side
    * allow setting sounds from freesound
    * - wake me up every morning at 8 am
    * - set an alarm for 5
    * - set an alarm for 5 on the last friday of the month
    * - set an alarm for noon using a pig sound
    * select which device/method to use to set the alarm
  * send a text to everyone attending that meeting 15 minutes before it starts with this conference call number: 812-555-5555
  * text messages
  * _ names/specific dates
    * my brithday
    * mom's birthday
      - connect to facebook/google/other
  * asking about what is possible (introspection)
    * maybe not easy ...
  * search google for X
  * open x's webpage (google feeling lucky? freebase?)
  * web or android?
    web - connect to X with X
    android - same kind of thing, but different interface?
  * ^^^^^^ MVP ^^^^^^
  * trueknowledge api ...
  * see for ideas: http://we.speaktoit.com/viewtopic.php?f=2&t=15
  * lookup X on netflix
  * lookup X on amazon
  * like a song
  * sports scores - tell them at http://forums.macrumors.com/showthread.php?t=1259708
  * theres a movie called eternal something or other ...
    * yeah thats it, is it on amazon?  sweet, play/buy!
  * craigslist ...
  * buy something on amazon (an album that is playing on pandora/last.fm)
  * put on a movie (netflix/amazon prime)
  * show a live feed of the senate
  * I'm reading XXX, does the author have any other books?
    * what is the next one in the series?
    * how much does it cost at amazon?
    * I'll take it!
  * see also dwi commands

  * freebase/YQL !?
    * teh beatles
    * get some more basic freebase translations built in
    * ! special cases?
        * for example, have a view for most objects, but special case some of them too
        * this would be a rule which says that if translation 1 matches, don't
          even test translation 2.
    * _ multiple results at once - rework the evaluator
        * first pass of this working.  Still might have problems in edge cases
    * ! how to automate/abstract the freebase translations?
        {
          "id":   null,
          "type": "/type/property",
          "/type/property/schema" : null,
          "/type/property/expected_type": {
            "id":   null,
            "type": "/type/type",
            "/freebase/type_hints/included_types": {
              "id": "/common/topic"
            }
          }
        }â€‹

* design for different use cases - focus on only one (android), quickly iterate 
  to desktop dragon naturally speaking version?
   * android - voice
   * desktop/wall/ipad - discussion

* we can not find all solutions.  This is because the Compiler is a turing 
  machine which is suceptible to the halting problem

* mission:
  to organize the world's thoughts and make them universally accessible
  to organize the world's intelligence and make it universally accessible
  to organize the world's desires and make them universally atainable
  to organize the world's dreams and make them universally atainable
  to organize life's dreams and make them universally atainable
  to organize Life's dreams and make them universally atainable
  to explore Life's dreams and make them universally atainable
  to discover Life's dreams and make them universally atainable
  to universally enable the discovery of Life's dreams and make them atainable
  to make Lifes' dreams universally atainable
